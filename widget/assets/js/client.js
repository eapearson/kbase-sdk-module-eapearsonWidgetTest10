/** A class which captures any error generated by the JSONRPC request. Typically subclassed
     * in order to provide more specific information.
     * It supports "KBase-style" JSON-RPC 1.1 errors.
     *
     * Note that in the context of the client, these error classes capture the error context in the
     * request to and response from a server. Some errors are captured before the request,
     * some during the request, some after.
     *
     * See `serverErrors.js` for errors propagated from the RPC error response.
     */
class ClientError extends Error {
    /**
     *
     * @param {string} message - A human-readable description of the error.
     * @param {Object} options - an "options style" parameter containing context common
     * to most, if not all, possible errors, which can optionally be displayed or logged
     * in order to provide fuller context for the error. The options is mandatory, but
     * each property is optional.
     * @param {string} [options.method] - The
     * @param {string} [options.params] -
     * @param {string} [options.url] -
     * @param {string} [options.originalMessage] -
     */
    constructor(message, { url, method, params, originalMessage }) {
        super(message);
        this.name = 'ClientError';

        if (typeof url === 'undefined') {
            throw new TypeError(
                'the "url" property is required in the second constructor argument'
            );
        }
        this.url = url;

        if (typeof method === 'undefined') {
            throw new TypeError(
                'the "method" property is required in the second constructor argument'
            );
        }
        this.method = method;

        // Optional
        this.params = params;
        this.originalMessage = originalMessage;
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            url: this.url,
            method: this.method,
            params: this.params,
            originalMessage: this.originalMessage,
        };
    }
}

/**
 * An error class which captures errors in the Request phase of a JSON-RPC call.
 */
class ClientRequestError extends ClientError {
    constructor(message, props) {
        super(message, props);
        this.name = 'ClientRequestError';
    }
}

/**
 * An error class which captures a timeout error during a JSON-RPC call.
 */
class ClientAbortError extends ClientRequestError {
    constructor(message, params) {
        super(message, params);
        this.name = 'ClientAbortError';
        const { timeout, elapsed, status } = params;
        if (typeof timeout === 'undefined') {
            throw new TypeError(
                'the "timeout" property is required in the second constructor argument'
            );
        }
        this.timeout = timeout;

        if (typeof elapsed === 'undefined') {
            throw new TypeError(
                'the "elapsed" property is required in the second constructor argument'
            );
        }
        this.elapsed = elapsed;

        if (typeof status === 'undefined') {
            throw new TypeError(
                'the "status" property is required in the second constructor argument'
            );
        }
        this.status = status;
    }
    toJSON() {
        const json = super.toJSON();
        json.timeout = this.timeout;
        json.elapsed = this.elapsed;
        json.status = this.status;
        return json;
    }
}

/**
 * An error class which captures an error during the Response phase of a JSON-RPC call.
 */
class ClientResponseError extends ClientError {
    constructor(message, params) {
        super(message, params);
        this.name = 'ClientResponseError';
        const { responseCode } = params;
        if (typeof responseCode === 'undefined') {
            throw new TypeError(
                'the "responseCode" property is required in the second constructor argument'
            );
        }
        this.responseCode = responseCode;
    }
    toJSON() {
        const json = super.toJSON();
        json.responseCode = this.responseCode;
        return json;
    }
}

/**
 * An error class which captures an error parsing the response text into JSON
 */
class ClientParseError extends ClientResponseError {
    constructor(message, params) {
        super(message, params);
        const { responseText } = params;
        if (typeof responseText === 'undefined') {
            throw new TypeError(
                'the "responseText" property is required in the second constructor argument'
            );
        }
        this.responseText = responseText;
        this.name = 'ClientParseError';
    }
    toJSON() {
        const json = super.toJSON();
        json.responseText = this.responseText;
        return json;
    }
}

class JSONRPCError extends Error {
    /**
     *
     * @param {string} message - A human-readable description of the error.
     * @param {Object} options - an "options style" parameter containing context common
     * to most, if not all, possible errors, which can optionally be displayed or logged
     * in order to provide fuller context for the error. The options is mandatory, but
     * each property is optional.
     * @param {string} [options.method] - The
     * @param {string} [options.params] -
     * @param {string} [options.url] -
     * @param {string} [options.originalMessage] -
     */
    constructor(errorMessage, { error: { name, code, message, error }, url, method, params }) {
        super(errorMessage);
        this.name = 'JSONRPCError';

        // Absorb the JSON-RPC error response.

        if (typeof code === 'undefined') {
            throw new Error(
                'the "error.code" property is required in the second constructor argument'
            );
        }

        if (typeof message === 'undefined') {
            throw new Error(
                'the "error.message" property is required in the second constructor argument'
            );
        }

        this.error = { code, message };

        // NB - "name" is required for JSON-RPC 1.1, but we generally use JSON-RPC 2.0
        // errors w/in JSON-RPC 1.1.
        if (typeof name !== 'undefined') {
            this.error.name = name;
        }

        if (typeof error !== 'undefined') {
            this.error.error = error;
        }

        // Other constructor properties are important attributes of the request
        // itself.

        if (typeof url === 'undefined') {
            throw new Error(
                'the "url" property is required in the second constructor argument'
            );
        }
        this.url = url;

        if (typeof method === 'undefined') {
            throw new Error(
                'the "method" property is required in the second constructor argument'
            );
        }
        this.method = method;

        // Optional
        this.params = params;
    }

    toJSONRPCError() {
        const error = {
            name: 'JSONRPCError',
            code: this.error.code,
            message: this.error.message,
        };
        if (typeof this.error.error !== 'undefined') {
            error.error = this.error.error;
        }
        return Object.assign({}, error);
    }
}

/**
 * An error class which captures a an error parsing the request text into JSON
 */
class JSONRPCParseError extends JSONRPCError {
    constructor(message, props) {
        props.error.code = -32700;
        super(message, props);
        this.name = 'JSONRPCParseError';
    }
}

class JSONRPCInvalidRequestError extends JSONRPCError {
    constructor(message, props) {
        props.error.code = -32600;
        super(message, props);
        this.name = 'JSONRPCInvalidRequestError';
    }
}

class JSONRPCMethodNotFoundError extends JSONRPCError {
    constructor(message, props) {
        props.error.code = -32601;
        super(message, props);
        this.name = 'JSONRPCMethodNotFoundError';
    }
}

class JSONRPCInvalidParamsError extends JSONRPCError {
    constructor(message, props) {
        props.error.code = -32602;
        super(message, props);
        this.name = 'JSONRPCInvalidParamsError';
    }
}

class JSONRPCInternalError extends JSONRPCError {
    constructor(message, props) {
        props.error.code = -32603;
        super(message, props);
        this.name = 'JSONRPCInternalError';
    }
}
class JSONRPCServerError extends JSONRPCError {
    constructor(message, props) {
        super(message, props);
        this.name = 'JSONRPCServerError';

        if (props.error.code > -32000 || props.error.code < -32099) {
            throw new TypeError(
                `the "code" constructor property must be between -32000 and -32099`
            );
        }
    }
}
class JSONRPCUnknownError extends JSONRPCError {
    constructor(message, props) {
        super(message, props);
        this.name = 'JSONRPCUnknownError';

        if (props.error.code > -32000 || props.error.code < -32768) {
            throw new TypeError(
                `the "code" constructor property must be between -32000 and -32768`
            );
        }
        if (
            [-32700, -32600, -32601, -32602, -32603].includes(props.error.code) ||
            (props.error.code <= -32000 && props.error.code >= -32099)
        ) {
            throw new TypeError(
                `the "code" constructor property must be not be a reserved JSON-RPC error code`
            );
        }
    }
}
class JSONRPCApplicationError extends JSONRPCError {
    constructor(message, props) {
        super(message, props);
        this.name = 'JSONRPCApplicationError';
        if (props.error.code <= -32000 && props.error.code >= -32768) {
            throw new TypeError(
                `the "code" constructor property must not be within the reserved inclusive range -32000 to -32768`
            );
        }
    }
}

function responseError(response, { url, method, params }) {
    const ErrorClass = (() => {
        switch (response.error.code) {
            case -32700:
                return JSONRPCParseError;
            case -32600:
                return JSONRPCInvalidRequestError;
            case -32601:
                return JSONRPCMethodNotFoundError;
            case -32602:
                return JSONRPCInvalidParamsError;
            case -32603:
                return JSONRPCInternalError;
            default:
                if (response.error.code <= -32000 && response.error.code >= -32099) {
                    return JSONRPCServerError;
                } else if (response.error.code > -32000 || response.error.code < -32768) {
                    return JSONRPCApplicationError;
                } else {
                    return JSONRPCUnknownError;
                }
        }
    })();
    return new ErrorClass(response.error.message, {
        error: response.error,
        url,
        method,
        params,
    });
}

 /**
     * A managed AbortController with timeout.
     */
 class AbortTimeoutController {
    /**
     *
     * @param {Object} param - named constructor params
     * @param {number} param.timeoutAfter - a time duration, in milliseconds, after which the abort signal is sent to the associated fetch request.
     */
    constructor({ timeoutAfter }) {
        this.timeoutAfter = timeoutAfter;
        this.controller = new AbortController();
        this.status = 'none';
        this.timeoutTimer = null;
        this.startedAt = null;
        this.timedoutAt = null;
    }

    /**
     * Starts the timeout monitor the for the associated request; aborts the request if the timeout expires.
     *
     * @returns {AbortTimeoutController} this object
     */
    start() {
        this.timeoutTimer = window.setTimeout(() => {
            this.timeout = null;
            this.status = 'timedout';
            this.timedoutAt = Date.now();
            this.controller.abort();
        }, this.timeoutAfter);
        this.startedAt = Date.now();
        this.status = 'started;';
        return this;
    }

    /**
     * Called to cancel the request (via the controller)
     *
     * @returns {AbortTimeoutController} this object
     */
    abort() {
        window.clearTimeout(this.timeoutTimer);
        this.timeout = null;
        this.status = 'aborted';
        this.controller.abort();
        return this;
    }

    /**
     * Should be called when the request is completed; cancels
     * the timeout timer.
     *
     * @returns {AbortTimeoutController} this object
     */
    stop() {
        window.clearTimeout(this.timeoutTimer);
        this.timeout = null;
        this.status = 'done';
        return this;
    }

    /**
     *
     * @returns {AbortSignal} Returns the signal property of the abort controller
     */
    getSignal() {
        return this.controller.signal;
    }

    /**
     *
     * @returns {string} The value of the internal status variable which tracks the state
     */
    getStatus() {
        return this.status;
    }

    getElapsed() {
        return this.timedoutAt - this.startedAt;
    }
}

class JSONRPCClient {
    /**
     *
     * @param {string} message - A human-readable description of the error.
     * @param {Object} options - an "options style" parameter containing context common
     * to most, if not all, possible errors, which can optionally be displayed or logged
     * in order to provide fuller context for the error. The options is mandatory, but
     * each property is optional.
     * @param {string} [options.method] - The
     * @param {string} [options.params] -
     * @param {string} [options.url] -
     * @param {string} [options.originalMessage] -
     */
    constructor({ url, timeout, authorization, strict = true }) {
        // API Usage error, not JSONRPC Error.
        if (typeof url === 'undefined') {
            throw new TypeError('The "url" is required');
        }
        this.url = url;

        // API Usage error, not JSONRPC Error.
        if (typeof timeout === 'undefined') {
            throw new TypeError('The "timeout" is required');
        }
        this.timeout = timeout;

        // Optional
        this.authorization = authorization;
        this.strict = strict;

        this.abortController = null;
    }

    /**
     * Aborts a pending request; same effect as a timeout but controlled procedurally.
     *
     * @returns {void} nothing
     */
    cancelPending() {
        this.controller.abort();
        this.controller = null;
    }

    fakeUUID() {
        return `${Date.now()}.${Math.random()*10000}`
    }

    /**
     * Calls the JSON-RPC endpoint with the given `method` and `params`, with behavior controlled
     * by `options`.
     *
     * @param {string} method
     * @param {Object} params
     * @param {Object} options
     * @returns
     */
    makeRPCRequest(method, params, options) {
        const rpc = {
            version: '1.1',
            method,
        };
        if (!options.omitId) {
            rpc.id = this.fakeUUID()
        }
        if (typeof params !== 'undefined') {
            rpc.params = params;
        }
        return rpc;
    }

    /**
     * Handles the response from a request to a JSON-RPC 1.1 server.
     *
     * @param {string} url - the original url for the request
     * @param {object} rpc - the original JSON-RPC request object sent in the request
     * @param {Response} response - the response object returned by fetch
     * @returns {object} - the JSON-RPC response object
     */
    async handleRPCResponse(url, rpc, response) {
        const { method, params } = rpc;

        // First handle basic parsing of the response. All responses should be JSON, even
        // errors. However, there are cases in which the service may be down or timing out
        // and we get a text-based response from a proxy, or the service is imperfect and may
        // return a text-based non-2xx response from the server layer.
        // We don't try to be clever with differentiating those circumstances, but rather
        // throw a single parsing error, which contains the context from the response,

        const responseText = await response.text();

        let jsonrpcResponse;
        try {
            jsonrpcResponse = JSON.parse(responseText);
        } catch (ex) {
            throw new ClientParseError('Error parsing response', {
                method,
                // because params may be undefined.
                params,
                url,
                responseCode: response.status,
                responseText,
                originalMessage: ex.message,
            });
        }

        // In strict mode, we try to honor the spec a bit more closely in areas
        // which, at least in the manner in which we (KBase) use JSON-RPC are
        // not critical, and we may relax.
        // - enforce rules for id
        // - enforce rules for version

        if (this.strict) {
            if (typeof rpc.id !== 'undefined') {
                if (typeof jsonrpcResponse.id === 'undefined' || jsonrpcResponse.id === null) {
                    // The id will be missing or null for parse errors, and may be missing for an invalid request */
                    if (
                        !(
                            jsonrpcResponse.error &&
                            [-32700, -32600].includes(jsonrpcResponse.error.code)
                        )
                    ) {
                        throw new ClientResponseError(`"id" missing in response`, {
                            method,
                            params,
                            url,
                            responseCode: response.status,
                        });
                    }
                } else {
                    if (jsonrpcResponse.id !== rpc.id) {
                        throw new ClientResponseError(
                            `"id" in response "${jsonrpcResponse.id}" does not match "id" in request "${rpc.id}"`,
                            { method, params, url, responseCode: response.status }
                        );
                    }
                }
            }

            if (typeof jsonrpcResponse.version === 'undefined') {
                throw new ClientResponseError('"version" property missing in response', {
                    method,
                    params,
                    url,
                    responseCode: response.status,
                });
            }
            if (jsonrpcResponse.version !== '1.1') {
                throw new ClientResponseError(
                    `"version" property is "${jsonrpcResponse.version}" not "1.1" as required`,
                    { method, params, url, responseCode: response.status }
                );
            }
        }

        // The state of the response can either be result, or error.

        if (typeof jsonrpcResponse.result !== 'undefined') {
            if (typeof jsonrpcResponse.error !== 'undefined') {
                throw new ClientResponseError(
                    'only one of "result" or "error" property may be provided in the response',
                    {
                        method,
                        params,
                        url,
                        responseCode: response.status,
                    }
                );
            }
            // Normal result response.
            return jsonrpcResponse.result;
        }

        if (typeof jsonrpcResponse.error === 'undefined') {
            throw new ClientResponseError('"result" or "error" property required in response', {
                method,
                params,
                url,
                responseCode: response.status,
            });
        }

        // Below here, everything throws
        // Note that when a method returns an error, the error code should
        // not be in the reserved range

        // server reported errors
        throw responseError(jsonrpcResponse, { url, method, params });
    }

    async request({ method, params, ...options }) {
        // API Usage error, not JSONRPC Error.
        if (typeof method === 'undefined') {
            throw new TypeError('The "method" is required');
        }
        const { url } = this;

        const timeout = options.timeout || this.timeout;

        const rpc = this.makeRPCRequest(method, params, options);

        // NB cannot add content-type, otherwise triggers CORS errors for cross-domain
        // requests because our servers are not always set up to respond to preflight requests,
        // which are triggered by certain usages (e.g. using Content-Type).
        // see: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests
        const headers = {};

        const authorization = options.authorization || this.authorization;
        if (authorization) {
            headers.Authorization = authorization;
        }

        const fetchOptions = {
            method: 'POST',
            mode: 'cors',
            cache: 'no-cache',
            headers,
            body: JSON.stringify(rpc),
        };

        // Enforce timeout and general abort handling via an abort controller
        const controller = new AbortTimeoutController({
            timeoutAfter: timeout,
        }).start();
        this.controller = controller;
        fetchOptions.signal = controller.getSignal();

        let response;
        try {
            response = await fetch(url, fetchOptions);
        } catch (ex) {
            if (ex instanceof DOMException && ex.name === 'AbortError') {
                const elapsed = controller.getElapsed();
                throw new ClientAbortError(
                    `Request aborted with status "${controller.status}" after ${elapsed}ms with timeout of ${timeout}ms`,
                    {
                        method,
                        params,
                        url,
                        status: controller.getStatus(),
                        timeout,
                        elapsed,
                        originalMessage: ex.message,
                    }
                );
            }
            throw new ClientRequestError('Network error', {
                method,
                params,
                url,
                originalMessage: ex.message,
            });
        } finally {
            controller.stop();
        }

        return this.handleRPCResponse(url, rpc, response);
    }

    
}

class ServiceClient {
    /**
     * A class representing a client for a KBase core service based on JSON-RPC 1.1
     *
     * @param {Object} param
     * @param {string} param.url
     * @param {string} param.module
     * @param {number} param.timeout
     * @param {string} [param.token]
     * @param {boolean} [param.strict] -
     */
    constructor({ url, module, timeout, token, strict }) {
        // Required
        if (typeof url === 'undefined') {
            throw new TypeError('"url" is required');
        }
        this.url = url;

        if (typeof module === 'undefined') {
            throw new TypeError('"module" is required');
        }
        this.module = module;

        if (typeof timeout === 'undefined') {
            throw new TypeError('"timeout" is required');
        }
        this.timeout = timeout;

        // Optional:
        this.token = token || null;
        this.strict = strict || false;
    }

    rpcCall(funcName, params, { timeout, token }) {
        let callParams;
        if (typeof params === 'undefined') {
            callParams = [];
        } else {
            callParams = [params];
        }

        timeout = timeout || this.timeout;
        const requestOptions = {};
        if (this.token) {
            requestOptions.authorization = this.token;
        }
        const constructorParams = { url: this.url, timeout, strict: this.strict };

        // Token can be overridden, or simply supplied by calls.
        const auth = token || this.token;
        if (auth) {
            constructorParams.authorization = auth;
        }

        const client = new JSONRPCClient(constructorParams);

        requestOptions.method = `${this.module}.${funcName}`;
        requestOptions.params = callParams;

        const request = client.request(requestOptions).then((response) => {
            if (!Array.isArray(response)) {
                throw new Error(`response is not an array`);
            }
            const [unwrapped] = response;
            return unwrapped;
        });

        return [request, client];
    }

    callFuncCancellable(funcName, params, options = {}) {
        const [request, client] = this.rpcCall(funcName, params, options);

        const canceller = () => {
            client.cancelPending();
        };

        return [request, canceller];
    }

    callFunc(funcName, params, options = {}) {
        const [request] = this.rpcCall(funcName, params, options);
        return request;
    }
}

function workspaceInfoToObject(wsInfo) {
    return {
        id: wsInfo[0],
        name: wsInfo[1],
        owner: wsInfo[2],
        moddate: wsInfo[3],
        object_count: wsInfo[4],
        user_permission: wsInfo[5],
        globalread: wsInfo[6],
        lockstat: wsInfo[7],
        metadata: wsInfo[8],
        modDate: new Date(wsInfo[3]).toISOString(),
        modifiedAt: new Date(wsInfo[3]).getTime()
    };
}

function objectInfoToObject(objInfo) {
    const type = objInfo[2].split(/[-.]/);

    return {
        id: objInfo[0],
        name: objInfo[1],
        type: objInfo[2],
        save_date: objInfo[3],
        version: objInfo[4],
        saved_by: objInfo[5],
        wsid: objInfo[6],
        ws: objInfo[7],
        checksum: objInfo[8],
        size: objInfo[9],
        metadata: objInfo[10],
        ref: objInfo[6] + '/' + objInfo[0] + '/' + objInfo[4],
        obj_id: 'ws.' + objInfo[6] + '.obj.' + objInfo[0],
        typeModule: type[0],
        typeName: type[1],
        typeMajorVersion: type[2],
        typeMinorVersion: type[3],
        saveDate: new Date(objInfo[3]).toISOString(),
        savedAt: new Date(objInfo[3]).getTime()
    };
}